# Гайд По Созданию Плагинов
## Создание проекта
Для создания плагинов вам потребуется знание языка программирования Rust.
Все начинается с объявления нового проекта.
```shell
cargo new название_плагина --lib
```
Поскольку в качестве плагинов используются dll-файлы, то стоит указать в `Cargo.toml`, что именно такой выход нам потребуется:
```toml
[lib]
crate-type = ["cdylib"]
```
В качестве принимаемых от приложения данных используется объект структуры `InterData`, определенной в `/inter_data_lib/lib.rs`. Для скачивания можно просто открыть репозиторий GitHub и скачать директорию данной библиотеки (наиболее простой способ).
Теперь нужно добавить зависимости в файл `Cargo.toml`, вот основные из них:
```toml
[dependencies]
idl = { path = "/путь/к/inter_data_lib/", package = "inter_data_lib" }
gtk4 = { version = "0.9", features = ["v4_12"] }
glib = "0.20"
gio = "0.20"
libloading = "0.8"  # Если вам потребуются зависимости в виде других плагинов.
```
## Основы
Теперь нужно написать сам код плагина. Всего есть три точки входа — функции `before_showing_window`, `after_showing_window` и `end`. Они принимают один параметр — изменяемый указатель на объект `InterData`: `*mut InterData` или же `idl::Data`. Возвращают указатель `Box` на потенциальное сообщение об ошибке: `Box<Option<String>>` или же `idl::Ret`.
Если соединить все во едино получается следующая сигнатура точки входа:
```rust
#[no_mangle]
pub extern "C" fn func(data: idl::Data) -> idl::Ret {...}
```
Для упрощения работы с ошибками рекомендуется писать следующим образом:
```rust
#[no_mangle]
pub extern "C" fn func(data: idl::Data) -> idl::Ret
{
    Box::new(|| -> Result<()> {
        ...
    }().err().as_ref().map(ToString::to_string))
}
```
### Использование макросов
Для упрощенной работы с `idl::Data` существует ряд макросов, а именно `get_gui_el` и `get_str`. Пример их использования:
```rust
#[no_mangle]
pub extern "C" fn func(data: idl::Data) -> idl::Ret
{
    Box::new(|| -> Result<()> {
        unsafe {
	        gtk4::set_initialized();
        }
        let window = idl::get_gui_el!(data.gui.window);
        println!(
	        "Версия приложения: {}\nРазмеры окна по умолчанию: {}",
	        idl::get_str!(data.version),
	        window.default_sizes(),
        );
        return Ok(());
    }().err().as_ref().map(ToString::to_string))
}
```
Также для упрощенной работы с объектами, методы которых возвращают `Option<T>`, предусмотрен макрос `get_attr`. Его синтаксис несколько сложнее, чем у предыдущих двух. Всего имеются 4 сценария его использования:
```rust
#[macro_export]
macro_rules! get_attr {
	(obj.method1::<...>(...)....methodN::<...>(...))
		=> obj
			.method1::<...>(...).ok_or(...)?
			...
			.methodN::<...>(...).ok_or(...)?
	([expr].method1::<...>(...)....methodN::<...>(...))
		=> (expr)
			.method1::<...>(...).ok_or(...)?
			...
			.methodN::<...>(...).ok_or(...)?
	(obj.method1::<...>(...)....methodN::<...>(...)?)
		=> obj
			.method1::<...>(...).ok_or(...)?
			...
			.methodN::<...>(...).ok_or(...)?
		.ok_or(...)?
	([expr].method1::<...>(...)....methodN::<...>(...)?)
		=> (expr)
			.method1::<...>(...).ok_or(...)?
			...
			.methodN::<...>(...).ok_or(...)?
		.ok_or(...)?
}
```
Последние два обычно используются без методов.
## Выпуск
После завершения плагина, его нужно скомпилировать:
```shell
cargo build --release
```
Переместить новосозданный бинарник в директорию с исполняемым файлом и добавить новую запись в `general_data.db`:
```sql
insert into Plugins values (<id>, <Название_плагина>, 0, <Зависимости_через_пробел>);
```